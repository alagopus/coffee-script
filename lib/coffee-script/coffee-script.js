// Generated by CoffeeScript 1.6.2
(function() {
  var Lexer, SourceMap, compile, compileJS, ext, extensions, file, helpers, iscoffee, lexer, loadFile, parser, wrapper, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  file = require('file');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  helpers = require('./helpers');

  SourceMap = require('./sourcemap');

  extensions = ['.coffee', '.litcoffee', '.md', '.coffee.md'];

  iscoffee = exports.iscoffee = function(filename) {
    var _ref;
    return !filename || (_ref = file.extension(filename), __indexOf.call(extensions, _ref) >= 0);
  };

  compileJS = function(scope, code, filename) {
    code = String(code);
    if (scope == null) {
      scope = global;
    }
    return Packages.org.mozilla.javascript.Context.getCurrentContext().evaluateString(scope, code, filename, 0, null);
  };

  wrapper = function(o) {
    var wrap;
    wrap = function(f) {
      if (f.prototype = o) {
        return f;
      }
    };
    return new wrap(function() {});
  };

  exports.VERSION = '1.6.2';

  exports.helpers = helpers;

  exports.compile = compile = function(code, options) {
    var answer, currentColumn, currentLine, fragment, fragments, header, js, map, merge, newLines, _i, _len;
    if (options == null) {
      options = {};
    }
    merge = helpers.merge;
    if (options.sourceMap) {
      map = new SourceMap;
    }
    fragments = parser.parse(lexer.tokenize(code, options)).compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (_i = 0, _len = fragments.length; _i < _len; _i++) {
      fragment = fragments[_i];
      if (options.sourceMap) {
        if (fragment.locationData) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        currentColumn = fragment.code.length - (newLines ? fragment.code.lastIndexOf("\n") : 0);
      }
      js += fragment.code;
    }
    if (options.header) {
      header = "Generated by CoffeeScript " + this.VERSION;
      js = "// " + header + "\n" + js;
    }
    if (options.sourceMap) {
      answer = {
        js: js
      };
      answer.sourceMap = map;
      answer.v3SourceMap = map.generate(options, code);
      return answer;
    } else {
      return js;
    }
  };

  exports.tokens = function(code, options) {
    return lexer.tokenize(code, options);
  };

  exports.nodes = function(source, options) {
    if (typeof source === 'string') {
      return parser.parse(lexer.tokenize(source, options));
    } else {
      return parser.parse(source);
    }
  };

  exports.run = function(code, options) {
    var answer, mainModule, scope;
    if (options == null) {
      options = {};
    }
    mainModule = require.main;
    if (options.sourceMap == null) {
      options.sourceMap = true;
    }
    if (options.filename != null) {
      mainModule.__filename = file.canonical(options.filename);
    }
    if (mainModule.__filename != null) {
      mainModule.__dirname = file.dirname(mainModule.__filename);
    }
    mainModule.moduleCache && (mainModule.moduleCache = {});
    mainModule.paths = [mainModule.__dirname];
    if (!(!iscoffee(options.filename) || require.extensions)) {
      answer = compile(code, options);
    }
    scope = mainModule;
    if (options.bare) {
      scope = wrapper(scope);
    }
    if (!mainModule._sourceMaps) {
      mainModule._sourceMaps = {};
    }
    mainModule._sourceMaps[mainModule.__filename] = answer.sourceMap;
    return compileJS(scope, answer.js, mainModule.__filename);
  };

  exports["eval"] = function(code, options) {
    var js, k, o, sandbox, v;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    if (options.sandbox != null) {
      sandbox = options.sandbox;
      sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
    } else {
      sandbox = global;
    }
    sandbox.__filename = options.filename || 'eval';
    sandbox.__dirname = file.dirname(sandbox.__filename);
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    return compileJS(sandbox, js, sandbox.__filename);
  };

  loadFile = function(module, filename) {
    var raw, stripped;
    raw = file.read(filename, {
      charset: 'utf-8'
    });
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    return compileJS(module, compile(stripped, {
      filename: filename
    }), filename);
  };

  if (require.extensions) {
    _ref = ['.coffee', '.litcoffee', '.md', '.coffee.md'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      require.extensions[ext] = loadFile;
    }
  }

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, token;
      token = this.tokens[this.pos++];
      if (token) {
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = require('./nodes');

  parser.yy.parseError = function(message, _arg) {
    var token;
    token = _arg.token;
    message = "unexpected " + (token === 1 ? 'end of input' : token);
    return helpers.throwSyntaxError(message, parser.lexer.yylloc);
  };

}).call(this);
