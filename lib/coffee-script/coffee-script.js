// Generated by CoffeeScript 1.4.0
(function() {
  var Lexer, RESERVED, compile, file, lexer, parser, stripBOM, _ref,
    __hasProp = {}.hasOwnProperty;

  file = require('file');

  _ref = require('./lexer'), Lexer = _ref.Lexer, RESERVED = _ref.RESERVED;

  parser = require('./parser').parser;

  stripBOM = function(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      return content.substring(1);
    } else {
      return content;
    }
  };

  if (require.extensions) {
    require.extensions['.coffee'] = function(module, filename) {
      var content;
      content = compile(stripBOM(file.canonical(filename, 'utf8')), {
        filename: filename
      });
      return module._compile(content, filename);
    };
  }

  exports.VERSION = '1.4.0';

  exports.RESERVED = RESERVED;

  exports.helpers = require('./helpers');

  exports.compile = compile = function(code, options) {
    var header, js, merge;
    if (options == null) {
      options = {};
    }
    merge = exports.helpers.merge;
    try {
      js = (parser.parse(lexer.tokenize(code))).compile(options);
      if (!options.header) {
        return js;
      }
    } catch (err) {
      if (options.filename) {
        err.message = "In " + options.filename + ", " + err.message;
      }
      throw err;
    }
    header = "Generated by CoffeeScript " + this.VERSION;
    return "// " + header + "\n" + js;
  };

  exports.tokens = function(code, options) {
    return lexer.tokenize(code, options);
  };

  exports.nodes = function(source, options) {
    if (typeof source === 'string') {
      return parser.parse(lexer.tokenize(source, options));
    } else {
      return parser.parse(source);
    }
  };

  exports.run = function(code, options) {
    var mainModule;
    if (options == null) {
      options = {};
    }
    mainModule = require.main;
    mainModule.filename = global["arguments"][0] = options.filename ? file.canonical(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = {});
    if (file.extension(mainModule.filename) !== '.coffee' || require.extensions) {
      return Function('__filename', compile(code, options))(mainModule.filename);
    } else {
      return Function('__filename', code)(mainModule.filename);
    }
  };

  exports["eval"] = function(code, options) {
    var js, k, o, v;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    return Function(js)();
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, _ref1;
      _ref1 = this.tokens[this.pos++] || [''], tag = _ref1[0], this.yytext = _ref1[1], this.yylineno = _ref1[2];
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = require('./nodes');

}).call(this);
