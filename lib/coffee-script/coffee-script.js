// Generated by CoffeeScript 1.5.0-pre
(function() {
  var Lexer, compile, compileJS, ext, extensions, file, lexer, loadFile, parser, _i, _len,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  file = require('file');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  extensions = ['.coffee', '.litcoffee'];

  compileJS = (function(){ function _compileJS(scope, code, filename) {
    var _compileJS;
    code = String(code);
    if (scope == null) {
      scope = global;
    }
    return Packages.org.mozilla.javascript.Context.getCurrentContext().evaluateString(scope, code, filename, 0, null);
  }; return _compileJS})();

  loadFile = (function(){ function _loadFile(module, filename) {
    var raw, stripped, _loadFile;
    raw = file.read(filename, {
      charset: 'utf-8'
    });
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    return compileJS(module, compile(stripped, {
      filename: filename
    }), filename);
  }; return _loadFile})();

  if (require.extensions) {
    for (_i = 0, _len = extensions.length; _i < _len; _i++) {
      ext = extensions[_i];
      require.extensions[ext] = loadFile;
    }
  }

  exports.VERSION = '1.5.0-pre';

  exports.helpers = require('./helpers');

  exports.compile = compile = (function(){ function _compile(code, options) {
    var header, js, merge, _compile;
    if (options == null) {
      options = {};
    }
    merge = exports.helpers.merge;
    try {
      js = (parser.parse(lexer.tokenize(code, options))).compile(options);
      if (!options.header) {
        return js;
      }
    } catch (err) {
      if (options.filename) {
        err.message = "In " + options.filename + ", " + err.message;
      }
      throw err;
    }
    header = "Generated by CoffeeScript " + this.VERSION;
    return "// " + header + "\n" + js;
  }; return _compile})();

  exports.tokens = (function(){ function _tokens(code, options) {
    var _tokens;
    return lexer.tokenize(code, options);
  }; return _tokens})();

  exports.nodes = (function(){ function _nodes(source, options) {
    var _nodes;
    if (typeof source === 'string') {
      return parser.parse(lexer.tokenize(source, options));
    } else {
      return parser.parse(source);
    }
  }; return _nodes})();

  exports.run = (function(){ function _run(code, options) {
    var mainModule, _ref, _run;
    if (options == null) {
      options = {};
    }
    mainModule = require.main;
    mainModule.filename = global["arguments"][0] = options.filename ? file.canonical(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = {});
    mainModule.paths = [file.dirname(file.canonical(options.filename))];
    if (!((_ref = file.extension(mainModule.filename), __indexOf.call(extensions, _ref) < 0) || require.extensions)) {
      code = compile(code, options);
    }
    return compileJS(mainModule, code, mainModule.filename);
  }; return _run})();

  exports["eval"] = function(code, options) {
    var js, k, o, sandbox, v;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    if (options.sandbox != null) {
      sandbox = options.sandbox;
      sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
    } else {
      sandbox = global;
    }
    sandbox.__filename = options.filename || 'eval';
    sandbox.__dirname = file.dirname(sandbox.__filename);
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    return compileJS(sandbox, js, sandbox.__filename);
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: (function(){ function _lex() {
      var tag, _lex, _ref;
      _ref = this.tokens[this.pos++] || [''], tag = _ref[0], this.yytext = _ref[1], this.yylineno = _ref[2];
      return tag;
    }; return _lex})(),
    setInput: (function(){ function _setInput(tokens) {
      var _setInput;
      this.tokens = tokens;
      return this.pos = 0;
    }; return _setInput})(),
    upcomingInput: (function(){ function _upcomingInput() {
      var _upcomingInput;
      return "";
    }; return _upcomingInput})()
  };

  parser.yy = require('./nodes');

}).call(this);
