// Generated by CoffeeScript 1.6.1
(function() {
  var BANNER, CoffeeScript, SWITCHES, compileJoin, compileOptions, compilePath, compileScript, compileStdio, file, fsa0, helpers, hidden, joinTimeout, lint, notSources, optionParser, optparse, opts, os, outputPath, parseOptions, printLine, printTokens, printWarn, removeSource, sourceCode, sources, system, timeLog, usage, version, wait, writeJs;

  fsa0 = require('fs-base');

  file = require('file');

  os = require('os');

  system = require('system');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  printLine = function(line) {
    return system.stdout.print(line);
  };

  printWarn = function(line) {
    return system.stderr.print(line);
  };

  hidden = function(f) {
    return /^\.|~$/.test(f);
  };

  BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

  SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-l', '--lint', 'pipe the compiled JavaScript through JavaScript Lint'], ['-m', '--map', 'generate source map and save as .map files'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number']];

  opts = {};

  sources = [];

  sourceCode = [];

  notSources = {};

  optionParser = null;

  exports.run = function() {
    var literals, source, _i, _len, _results;
    parseOptions();
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.interactive) {
      return require('./repl');
    }
    if (opts.stdio) {
      return compileStdio();
    }
    if (opts["eval"]) {
      return compileScript(null, sources[0]);
    }
    if (!sources.length) {
      return require('./repl');
    }
    literals = opts.run ? sources.splice(1) : [];
    global["arguments"] = global["arguments"].slice(0, 1).concat(literals);
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      _results.push(compilePath(source, true, file.resolve(source)));
    }
    return _results;
  };

  compilePath = function(source, topLevel, base) {
    var code, f, files, index, _ref, _ref1;
    if (!file.exists(source)) {
      if (topLevel && !CoffeeScript.iscoffee(source)) {
        source = sources[sources.indexOf(source)] = "" + source + ".coffee";
        return compilePath(source, topLevel, base);
      }
      if (topLevel) {
        system.stderr.print("File not found: " + source);
        os.exit(1);
      }
    } else if (file.isDirectory(source)) {
      files = file.list(source);
      index = sources.indexOf(source);
      files = files.filter(function(f) {
        return !hidden(f);
      });
      [].splice.apply(sources, [index, index - index + 1].concat(_ref = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          f = files[_i];
          _results.push(file.join(source, f));
        }
        return _results;
      })())), _ref;
      [].splice.apply(sourceCode, [index, index - index + 1].concat(_ref1 = files.map(function() {
        return null;
      }))), _ref1;
      return files.forEach(function(f) {
        return compilePath(file.join(source, f), false, base);
      });
    } else if (topLevel || CoffeeScript.iscoffee(source)) {
      code = file.read(source);
      return compileScript(source, code.toString(), base);
    } else {
      notSources[source] = true;
      return removeSource(source, base);
    }
  };

  compileScript = function(f, input, base) {
    var compiled, err, o, options, t;
    o = opts;
    options = compileOptions(f);
    try {
      t = {
        file: f,
        input: input,
        options: options
      };
      if (o.tokens) {
        return printTokens(CoffeeScript.tokens(t.input, t.options));
      } else if (o.nodes) {
        return printLine(CoffeeScript.nodes(t.input, t.options).toString().trim());
      } else if (o.run) {
        return CoffeeScript.run(t.input, t.options);
      } else if (o.join && t.file !== o.join) {
        if (helpers.isLiterate(file)) {
          t.input = helpers.invertLiterate(t.input);
        }
        sourceCode[sources.indexOf(t.file)] = t.input;
        return compileJoin();
      } else {
        compiled = CoffeeScript.compile(t.input, t.options);
        t.output = compiled;
        if (o.map) {
          t.output = compiled.js;
          t.sourceMap = compiled.v3SourceMap;
        }
        if (o.print) {
          return printLine(t.output.trim());
        } else if (o.compile || o.map) {
          return writeJs(base, t.file, t.output, t.sourceMap);
        } else if (o.lint) {
          return lint(t.file, t.output);
        }
      }
    } catch (_error) {
      err = _error;
      printWarn("ERROR: " + err);
      return os.exit(1);
    }
  };

  compileStdio = function() {
    return compileScript(null, system.stdin.read());
  };

  joinTimeout = null;

  compileJoin = function() {
    if (!opts.join) {
      return;
    }
    if (!sourceCode.some(function(code) {
      return code === null;
    })) {
      clearTimeout(joinTimeout);
      return joinTimeout = wait(100, function() {
        return compileScript(opts.join, sourceCode.join('\n'), opts.join);
      });
    }
  };

  removeSource = function(source, base) {
    var index;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    return sourceCode.splice(index, 1);
  };

  outputPath = function(source, base, extension) {
    var baseDir, dir, filename, srcDir;
    if (extension == null) {
      extension = '.js';
    }
    filename = file.basename(source, file.extension(source)) + extension;
    srcDir = file.dirname(source);
    baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
    dir = opts.output ? file.join(opts.output, baseDir) : srcDir;
    return file.resolve(dir, filename);
  };

  writeJs = function(base, source, js, generatedSourceMap) {
    var jsDir, jsPath, sourceMapPath;
    if (generatedSourceMap == null) {
      generatedSourceMap = null;
    }
    jsPath = outputPath(source, base);
    sourceMapPath = outputPath(source, base, ".map");
    jsDir = file.dirname(jsPath);
    if (js.length <= 0) {
      js = ' ';
    }
    if (generatedSourceMap) {
      file.write(sourceMapPath, generatedSourceMap);
      js = "" + js + "\n/*\n//@ sourceMappingURL=" + (helpers.baseFileName(sourceMapPath)) + "\n*/\n";
    }
    return file.write(jsPath, js);
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  lint = function(f, js) {
    var conf, jsl, printIt;
    printIt = function(buffer) {
      return printLine(f + ':\t' + buffer.toString().trim());
    };
    conf = __dirname + '/../../extras/jsl.conf';
    jsl = os.popen("jsl -nologo -stdin -conf " + conf);
    jsl.stdout.on('data', printIt);
    jsl.stderr.on('data', printIt);
    jsl.stdin.write(js);
    return jsl.stdin.end();
  };

  printTokens = function(tokens) {
    var strings, tag, token, value;
    strings = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        tag = token[0];
        value = token[1].toString().replace(/\n/, '\\n');
        _results.push("[" + tag + " " + value + "]");
      }
      return _results;
    })();
    return printLine(strings.join(' '));
  };

  parseOptions = function() {
    var i, o, source, _i, _len;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    o = opts = optionParser.parse(global["arguments"].slice(1));
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.lint || o.map);
    o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
    sources = o["arguments"];
    for (i = _i = 0, _len = sources.length; _i < _len; i = ++_i) {
      source = sources[i];
      sourceCode[i] = null;
    }
  };

  compileOptions = function(filename) {
    var literate;
    literate = file.extension(filename) === '.litcoffee';
    return {
      filename: filename,
      literate: literate,
      bare: opts.bare,
      header: opts.compile,
      sourceMap: opts.map
    };
  };

  usage = function() {
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  };

  version = function() {
    return printLine("CoffeeScript version " + CoffeeScript.VERSION);
  };

}).call(this);
