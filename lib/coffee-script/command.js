// Generated by CoffeeScript 1.6.2
(function() {
  var BANNER, CoffeeScript, SWITCHES, compileJoin, compileOptions, compilePath, compileScript, compileStdio, file, fsa0, helpers, hidden, joinTimeout, notSources, optionParser, optparse, opts, os, outputPath, parseOptions, printLine, printTokens, printWarn, removeSource, sourceCode, sources, system, timeLog, usage, version, wait, writeJs;

  fsa0 = require('fs-base');

  file = require('file');

  os = require('os');

  system = require('system');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  printLine = function(line) {
    return system.stdout.print(line);
  };

  printWarn = function(line) {
    return system.stderr.print(line);
  };

  hidden = function(f) {
    return /^\.|~$/.test(f);
  };

  BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

  SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .map files'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-l', '--literate', 'treat stdio as literate style coffee-script'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-x', '--extension [ext]', 'use this extension for the JavaScript file instead of .js (must be used before e.g. -m flag)']];

  opts = {};

  sources = [];

  sourceCode = [];

  notSources = {};

  optionParser = null;

  exports.run = function() {
    var literals, source, _i, _len, _results;
    parseOptions();
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.interactive) {
      return require('./repl');
    }
    if (opts.stdio) {
      return compileStdio();
    }
    if (opts["eval"]) {
      return compileScript(null, sources[0]);
    }
    if (!sources.length) {
      return require('./repl');
    }
    literals = opts.run ? sources.splice(1) : [];
    global["arguments"] = global["arguments"].slice(0, 1).concat(literals);
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      _results.push(compilePath(source, true, file.resolve(source)));
    }
    return _results;
  };

  compilePath = function(source, topLevel, base) {
    var code, f, files, index, _ref, _ref1;
    if (!file.exists(source)) {
      if (topLevel && !CoffeeScript.iscoffee(source)) {
        source = sources[sources.indexOf(source)] = "" + source + ".coffee";
        return compilePath(source, topLevel, base);
      }
      if (topLevel) {
        system.stderr.print("File not found: " + source);
        os.exit(1);
      }
    } else if (file.isDirectory(source)) {
      files = file.list(source);
      index = sources.indexOf(source);
      files = files.filter(function(f) {
        return !hidden(f);
      });
      [].splice.apply(sources, [index, index - index + 1].concat(_ref = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          f = files[_i];
          _results.push(file.join(source, f));
        }
        return _results;
      })())), _ref;
      [].splice.apply(sourceCode, [index, index - index + 1].concat(_ref1 = files.map(function() {
        return null;
      }))), _ref1;
      return files.forEach(function(f) {
        return compilePath(file.join(source, f), false, base);
      });
    } else if (topLevel || CoffeeScript.iscoffee(source)) {
      code = file.read(source);
      return compileScript(source, code.toString(), base);
    } else {
      notSources[source] = true;
      return removeSource(source, base);
    }
  };

  compileScript = function(f, input, base) {
    var compiled, err, message, o, options, t;
    o = opts;
    options = compileOptions(f, base);
    try {
      t = {
        file: f,
        input: input,
        options: options
      };
      if (o.tokens) {
        return printTokens(CoffeeScript.tokens(t.input, t.options));
      } else if (o.nodes) {
        return printLine(CoffeeScript.nodes(t.input, t.options).toString().trim());
      } else if (o.run) {
        return CoffeeScript.run(t.input, t.options);
      } else if (o.join && t.file !== o.join) {
        if (helpers.isLiterate(file)) {
          t.input = helpers.invertLiterate(t.input);
        }
        sourceCode[sources.indexOf(t.file)] = t.input;
        return compileJoin();
      } else {
        compiled = CoffeeScript.compile(t.input, t.options);
        t.output = compiled;
        if (o.map) {
          t.output = compiled.js;
          t.sourceMap = compiled.v3SourceMap;
        }
        if (o.print) {
          return printLine(t.output.trim());
        } else if (o.compile || o.map) {
          return writeJs(base, t.file, t.output, options.jsPath, t.sourceMap);
        }
      }
    } catch (_error) {
      err = _error;
      message = helpers.prettyErrorMessage(err, file || '[stdin]', input);
      printWarn(message);
      return os.exit(1);
    }
  };

  compileStdio = function() {
    return compileScript(null, system.stdin.read());
  };

  joinTimeout = null;

  compileJoin = function() {
    if (!opts.join) {
      return;
    }
    if (!sourceCode.some(function(code) {
      return code === null;
    })) {
      clearTimeout(joinTimeout);
      return joinTimeout = wait(100, function() {
        return compileScript(opts.join, sourceCode.join('\n'), opts.join);
      });
    }
  };

  removeSource = function(source, base) {
    var index;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    return sourceCode.splice(index, 1);
  };

  outputPath = function(source, base, extension) {
    var baseDir, dir, filename, srcDir;
    if (extension == null) {
      extension = '.js';
    }
    filename = file.basename(source, file.extension(source)) + extension;
    srcDir = file.dirname(source);
    baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
    dir = opts.output ? file.join(opts.output, baseDir) : srcDir;
    if (dir) {
      filename = file.join(dir, filename);
    }
    return filename;
  };

  writeJs = function(base, source, js, jsPath, generatedSourceMap) {
    var jsDir, sourceMapPath;
    if (generatedSourceMap == null) {
      generatedSourceMap = null;
    }
    sourceMapPath = outputPath(source, base, ".map");
    jsDir = file.dirname(jsPath);
    if (js.length <= 0) {
      js = ' ';
    }
    if (generatedSourceMap) {
      file.write(sourceMapPath, generatedSourceMap);
      js = "" + js + "\n/*\n//@ sourceMappingURL=" + (helpers.baseFileName(sourceMapPath)) + "\n*/\n";
    }
    return file.write(jsPath, js);
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  printTokens = function(tokens) {
    var strings, tag, token, value;
    strings = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        tag = token[0];
        value = token[1].toString().replace(/\n/, '\\n');
        _results.push("[" + tag + " " + value + "]");
      }
      return _results;
    })();
    return printLine(strings.join(' '));
  };

  parseOptions = function() {
    var i, o, source, _i, _len;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    o = opts = optionParser.parse(global["arguments"]);
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.map);
    o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
    sources = o["arguments"];
    for (i = _i = 0, _len = sources.length; _i < _len; i = ++_i) {
      source = sources[i];
      sourceCode[i] = null;
    }
  };

  compileOptions = function(filename, base) {
    var answer, literate;
    literate = opts.literate || file.extension(filename) === '.litcoffee';
    answer = {
      filename: filename,
      literate: literate,
      bare: opts.bare,
      header: opts.compile,
      sourceMap: opts.map
    };
    if (filename) {
      answer.jsPath = outputPath(filename, base, opts.extension);
      answer.sourceRoot = file.relative(answer.jsPath, '.');
      answer.sourceFiles = [file.relative(filename)];
      answer.generatedFile = helpers.baseFileName(answer.jsPath);
    }
    return answer;
  };

  usage = function() {
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  };

  version = function() {
    return printLine("CoffeeScript version " + CoffeeScript.VERSION);
  };

}).call(this);
