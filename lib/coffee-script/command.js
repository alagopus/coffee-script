// Generated by CoffeeScript 1.5.0-pre
(function() {
  var BANNER, CoffeeScript, SWITCHES, compileJoin, compileOptions, compilePath, compileScript, compileStdio, file, fsa0, helpers, hidden, joinTimeout, lint, loadRequires, notSources, optionParser, optparse, opts, os, outputPath, parseOptions, printLine, printTokens, printWarn, removeSource, sourceCode, sources, system, usage, version, wait, writeJs;

  fsa0 = require('fs-base');

  file = require('file');

  os = require('os');

  system = require('system');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  printLine = (function(){ function _printLine(line) {
    var _printLine;
    return system.stdout.print(line);
  }; return _printLine})();

  printWarn = (function(){ function _printWarn(line) {
    var _printWarn;
    return system.stderr.print(line);
  }; return _printWarn})();

  hidden = (function(){ function _hidden(f) {
    var _hidden;
    return /^\.|~$/.test(f);
  }; return _hidden})();

  BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

  SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-l', '--lint', 'pipe the compiled JavaScript through JavaScript Lint'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-r', '--require [FILE*]', 'require a library before executing your script'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number']];

  opts = {};

  sources = [];

  sourceCode = [];

  notSources = {};

  optionParser = null;

  exports.run = (function(){ function _run() {
    var literals, source, _i, _len, _results, _run;
    parseOptions();
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.require) {
      loadRequires();
    }
    if (opts.interactive) {
      return require('./repl');
    }
    if (opts.stdio) {
      return compileStdio();
    }
    if (opts["eval"]) {
      return compileScript(null, sources[0]);
    }
    if (!sources.length) {
      return require('./repl');
    }
    literals = opts.run ? sources.splice(1) : [];
    global["arguments"] = global["arguments"].slice(0, 1).concat(literals);
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      _results.push(compilePath(source, true, file.resolve(source)));
    }
    return _results;
  }; return _run})();

  compilePath = (function(){ function _compilePath(source, topLevel, base) {
    var code, f, files, index, _compilePath, _ref, _ref1;
    if (!file.exists(source)) {
      if (topLevel && !CoffeeScript.iscoffee(source)) {
        source = sources[sources.indexOf(source)] = "" + source + ".coffee";
        return compilePath(source, topLevel, base);
      }
      if (topLevel) {
        system.stderr.print("File not found: " + source);
        os.exit(1);
      }
    } else if (file.isDirectory(source)) {
      files = file.list(source);
      index = sources.indexOf(source);
      files = files.filter(function(f) {
        return !hidden(f);
      });
      [].splice.apply(sources, [index, index - index + 1].concat(_ref = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          f = files[_i];
          _results.push(file.join(source, f));
        }
        return _results;
      })())), _ref;
      [].splice.apply(sourceCode, [index, index - index + 1].concat(_ref1 = files.map(function() {
        return null;
      }))), _ref1;
      return files.forEach(function(f) {
        return compilePath(file.join(source, f), false, base);
      });
    } else if (topLevel || CoffeeScript.iscoffee(source)) {
      code = file.read(source);
      return compileScript(source, code.toString(), base);
    } else {
      notSources[source] = true;
      return removeSource(source, base);
    }
  }; return _compilePath})();

  compileScript = (function(){ function _compileScript(f, input, base) {
    var o, options, t, _compileScript;
    o = opts;
    options = compileOptions(f);
    try {
      t = {
        file: f,
        input: input,
        options: options
      };
      if (o.tokens) {
        return printTokens(CoffeeScript.tokens(t.input, t.options));
      } else if (o.nodes) {
        return printLine(CoffeeScript.nodes(t.input, t.options).toString().trim());
      } else if (o.run) {
        return CoffeeScript.run(t.input, t.options);
      } else if (o.join && t.file !== o.join) {
        sourceCode[sources.indexOf(t.file)] = t.input;
        return compileJoin();
      } else {
        t.output = CoffeeScript.compile(t.input, t.options);
        if (o.print) {
          return printLine(t.output.trim());
        } else if (o.compile) {
          return writeJs(t.file, t.output, base);
        } else if (o.lint) {
          return lint(t.file, t.output);
        }
      }
    } catch (err) {
      printWarn("ERROR: " + err);
      return os.exit(1);
    }
  }; return _compileScript})();

  compileStdio = (function(){ function _compileStdio() {
    var _compileStdio;
    return compileScript(null, system.stdin.read());
  }; return _compileStdio})();

  joinTimeout = null;

  compileJoin = (function(){ function _compileJoin() {
    var _compileJoin;
    if (!opts.join) {
      return;
    }
    if (!sourceCode.some(function(code) {
      return code === null;
    })) {
      clearTimeout(joinTimeout);
      return joinTimeout = wait(100, function() {
        return compileScript(opts.join, sourceCode.join('\n'), opts.join);
      });
    }
  }; return _compileJoin})();

  loadRequires = (function(){ function _loadRequires() {
    var realFilename, req, _i, _len, _loadRequires, _ref;
    realFilename = module.filename;
    module.filename = '.';
    _ref = opts.require;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      req = _ref[_i];
      require(req);
    }
    return module.filename = realFilename;
  }; return _loadRequires})();

  removeSource = (function(){ function _removeSource(source, base) {
    var index, _removeSource;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    return sourceCode.splice(index, 1);
  }; return _removeSource})();

  outputPath = (function(){ function _outputPath(source, base) {
    var baseDir, dir, filename, srcDir, _outputPath;
    filename = file.basename(source, file.extension(source)) + '.js';
    srcDir = file.dirname(source);
    baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
    dir = opts.output ? file.join(opts.output, baseDir) : srcDir;
    return file.resolve(dir, filename);
  }; return _outputPath})();

  writeJs = (function(){ function _writeJs(source, js, base) {
    var jsDir, jsPath, _writeJs;
    jsPath = outputPath(source, base);
    jsDir = file.dirname(jsPath);
    if (js.length <= 0) {
      js = ' ';
    }
    return file.write(jsPath, js);
  }; return _writeJs})();

  wait = (function(){ function _wait(milliseconds, func) {
    var _wait;
    return setTimeout(func, milliseconds);
  }; return _wait})();

  lint = (function(){ function _lint(f, js) {
    var conf, jsl, printIt, _lint;
    printIt = (function(){ function _printIt(buffer) {
      var _printIt;
      return printLine(f + ':\t' + buffer.toString().trim());
    }; return _printIt})();
    conf = __dirname + '/../../extras/jsl.conf';
    jsl = os.popen("jsl -nologo -stdin -conf " + conf);
    jsl.stdout.on('data', printIt);
    jsl.stderr.on('data', printIt);
    jsl.stdin.write(js);
    return jsl.stdin.end();
  }; return _lint})();

  printTokens = (function(){ function _printTokens(tokens) {
    var strings, tag, token, value, _printTokens;
    strings = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        _ref = [token[0], token[1].toString().replace(/\n/, '\\n')], tag = _ref[0], value = _ref[1];
        _results.push("[" + tag + " " + value + "]");
      }
      return _results;
    })();
    return printLine(strings.join(' '));
  }; return _printTokens})();

  parseOptions = (function(){ function _parseOptions() {
    var i, o, source, _i, _len, _parseOptions;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    o = opts = optionParser.parse(global["arguments"].slice(1));
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.lint);
    o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
    sources = o["arguments"];
    for (i = _i = 0, _len = sources.length; _i < _len; i = ++_i) {
      source = sources[i];
      sourceCode[i] = null;
    }
  }; return _parseOptions})();

  compileOptions = (function(){ function _compileOptions(filename) {
    var literate, _compileOptions;
    literate = file.extension(filename) === '.litcoffee';
    return {
      filename: filename,
      literate: literate,
      bare: opts.bare,
      header: opts.compile
    };
  }; return _compileOptions})();

  usage = (function(){ function _usage() {
    var _usage;
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  }; return _usage})();

  version = (function(){ function _version() {
    var _version;
    return printLine("CoffeeScript version " + CoffeeScript.VERSION);
  }; return _version})();

}).call(this);
