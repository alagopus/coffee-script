# CoffeeScript can be used both on the server, as a command-line compiler based
# on Node.js/V8, or to run CoffeeScripts directly in the browser. This module
# contains the main entry functions for tokenizing, parsing, and compiling
# source CoffeeScript into JavaScript.
#
# If included on a webpage, it will automatically sniff out, compile, and
# execute all scripts present in `text/coffeescript` tags.

file      = require 'file'
{Lexer}   = require './lexer'
{parser}  = require './parser'
helpers   = require './helpers'
sourcemap = require './sourcemap'

# The file extensions that are considered to be CoffeeScript.
extensions = ['.coffee', '.litcoffee', '.md', '.coffee.md']

iscoffee = exports.iscoffee = (filename) ->
  not filename or file.extension(filename) in extensions

compileJS = (scope, code, filename) ->
  code = String(code)
  scope = global unless scope?
  Packages.org.mozilla.javascript.Context.getCurrentContext().evaluateString scope, code, filename, 0, null

wrapper = (o) ->
  wrap = (f) -> f if f.prototype = o
  new wrap ->

# Load and run a CoffeeScript file for Node, stripping any `BOM`s.
loadFile = (module, filename) ->
  raw = file.read filename, { charset: 'utf-8' }
  stripped = if raw.charCodeAt(0) is 0xFEFF then raw.substring 1 else raw
  compileJS module, compile(stripped, {filename}), filename

if require.extensions
  for ext in ['.coffee', '.litcoffee', '.md', '.coffee.md']
    require.extensions[ext] = loadFile

# The current CoffeeScript version number.
exports.VERSION = '1.6.1'

# Expose helpers for testing.
exports.helpers = helpers

# Compile CoffeeScript code to JavaScript, using the Coffee/Jison compiler.
#
# If `options.sourceMap` is specified, then `options.filename` must also be specified.  All
# options that can be passed to `generateV3SourceMap()` may also be passed here.
#
# This returns a javascript string, unless `options.sourceMap` is passed,
# in which case this returns a `{js, v3SourceMap, sourceMap}
# object, where sourceMap is a sourcemap.coffee#SourceMap object, handy for doing programatic
# lookups.
exports.compile = compile = (code, options = {}) ->
  {merge} = exports.helpers

  if options.sourceMap
    sourceMap = new sourcemap.SourceMap()

  fragments = (parser.parse lexer.tokenize(code, options)).compileToFragments options

  currentLine = 0
  currentLine += 1 if options.header
  currentColumn = 0
  js = ""
  for fragment in fragments
    # Update the sourcemap with data from each fragment
    if sourceMap
      if fragment.locationData
        sourceMap.addMapping(
          [fragment.locationData.first_line, fragment.locationData.first_column],
          [currentLine, currentColumn],
          {noReplace: true})
      newLines = helpers.count fragment.code, "\n"
      currentLine += newLines
      currentColumn = fragment.code.length - (if newLines then fragment.code.lastIndexOf "\n" else 0)

    # Copy the code from each fragment into the final JavaScript.
    js += fragment.code

  if options.header
    header = "Generated by CoffeeScript #{@VERSION}"
    js = "// #{header}\n#{js}"

  if options.sourceMap
    answer = {js}
    if sourceMap
      answer.sourceMap = sourceMap
      answer.v3SourceMap = sourcemap.generateV3SourceMap(sourceMap, options)
    answer
  else
    js

# Tokenize a string of CoffeeScript code, and return the array of tokens.
exports.tokens = (code, options) ->
  lexer.tokenize code, options

# Parse a string of CoffeeScript code or an array of lexed tokens, and
# return the AST. You can then compile it by calling `.compile()` on the root,
# or traverse it by using `.traverseChildren()` with a callback.
exports.nodes = (source, options) ->
  if typeof source is 'string'
    parser.parse lexer.tokenize source, options
  else
    parser.parse source

# Compile and execute a string of CoffeeScript (on the server), correctly
# setting `__filename`, `__dirname`, and relative `require()`.
exports.run = (code, options = {}) ->
  mainModule = require.main

  mainModule.__filename = file.canonical(options.filename) if options.filename?
  mainModule.__dirname  = file.dirname mainModule.__filename if mainModule.__filename?

  # Clear the module cache.
  mainModule.moduleCache and= {}

  # Assign paths for node_modules loading
  mainModule.paths = [ mainModule.__dirname ]

  # Compile.
  unless not iscoffee(options.filename) or require.extensions
    code = compile(code, options)
  scope = mainModule
  if options.bare
    scope = wrapper scope
  compileJS scope, code, mainModule.__filename

# The CoffeeScript REPL uses this to run the input.
exports.eval = (code, options = {}) ->
  return unless code = code.trim()
  if options.sandbox?
    sandbox = options.sandbox
    sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox
  else
    sandbox = global
  sandbox.__filename = options.filename || 'eval'
  sandbox.__dirname  = file.dirname sandbox.__filename
  o = {}
  o[k] = v for own k, v of options
  o.bare = on # ensure return value
  js = compile code, o
  compileJS sandbox, js, sandbox.__filename

# Instantiate a Lexer for our use here.
lexer = new Lexer

# The real Lexer produces a generic stream of tokens. This object provides a
# thin wrapper around it, compatible with the Jison API. We can then pass it
# directly as a "Jison lexer".
parser.lexer =
  lex: ->
    token = @tokens[@pos++]
    if token
      [tag, @yytext, @yylloc] = token
      @yylineno = @yylloc.first_line
    else
      tag = ''

    tag
  setInput: (@tokens) ->
    @pos = 0
  upcomingInput: ->
    ""

# Make all the AST nodes visible to the parser.
parser.yy = require './nodes'

# Override Jison's default error handling function.
parser.yy.parseError = (message, {token}) ->
  # Disregard Jison's message, it contains redundant line numer information.
  message = "unexpected #{if token is 1 then 'end of input' else token}"
  # The second argument has a `loc` property, which should have the location
  # data for this token. Unfortunately, Jison seems to send an outdated `loc`
  # (from the previous token), so we take the location information directly
  # from the lexer.
  helpers.throwSyntaxError message, parser.lexer.yylloc
